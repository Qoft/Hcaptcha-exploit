package hcaptcha

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"
)

func New(host, sitekey string, verbose bool) *HCaptcha {
	return &HCaptcha{
		Host:       host,
		SiteKey:    sitekey,
		HTTPClient: &http.Client{},
		Verbose:    verbose,
	}
}

func (client *HCaptcha) CheckSiteConfig() *CheckSiteConfigResponse {
	query := url.Values{}
	query.Add("v", Version)
	query.Add("host", client.Host)
	query.Add("sitekey", client.SiteKey)
	query.Add("sc", "1")
	query.Add("swa", "1")

	req, err := http.NewRequest("GET", fmt.Sprintf("%v/checksiteconfig?%v", BaseURL, query.Encode()), nil)
	HandleError(err)

	req.Header.Set("accept", "application/json")
	req.Header.Set("accept-language", "en-GB,en-US;q=0.9,en;q=0.8")
	req.Header.Set("content-type", "application/x-www-form-urlencoded")
	req.Header.Set("origin", "https://newassets.hcaptcha.com")
	req.Header.Set("referer", "https://newassets.hcaptcha.com/")
	req.Header.Set("sec-fetch-dest", "empty")
	req.Header.Set("sec-fetch-mode", "cors")
	req.Header.Set("sec-fetch-site", "same-site")
	req.Header.Set("sec-gpc", "1")
	req.Header.Set("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36")

	res, err := client.HTTPClient.Do(req)
	HandleError(err)

	var reply CheckSiteConfigResponse

	err = json.NewDecoder(res.Body).Decode(&reply)
	HandleError(err)

	if !reply.Pass {
		if client.Verbose {
			fmt.Println("[~] Failed to complete: checksiteconfig")
		}
		return client.CheckSiteConfig()
	}

	if client.Verbose {
		fmt.Println("[~] Completed: checksiteconfig")
	}

	return &reply
}

func (client *HCaptcha) GetCaptcha(siteConfig *CheckSiteConfigResponse, motionData string) *GetCaptchaResponse {
	hash, err := HSWHashProof(siteConfig.C.Req)
	HandleError(err)

	c_data, err := json.Marshal(siteConfig.C)
	HandleError(err)

	query := url.Values{}
	query.Add("v", Version)
	query.Add("host", client.Host)
	query.Add("sitekey", client.SiteKey)
	query.Add("hl", "en")
	query.Add("motionData", motionData)
	query.Add("n", hash)
	query.Add("c", string(c_data))

	req, err := http.NewRequest("POST", fmt.Sprintf("%v/getcaptcha/%v", BaseURL, URLEncode(client.SiteKey)), strings.NewReader(query.Encode()))
	HandleError(err)

	req.Header.Set("accept", "application/json")
	req.Header.Set("accept-language", "en-GB,en-US;q=0.9,en;q=0.8")
	req.Header.Set("content-type", "application/x-www-form-urlencoded")
	req.Header.Set("origin", "https://newassets.hcaptcha.com")
	req.Header.Set("referer", "https://newassets.hcaptcha.com/")
	req.Header.Set("sec-fetch-dest", "empty")
	req.Header.Set("sec-fetch-mode", "cors")
	req.Header.Set("sec-fetch-site", "same-site")
	req.Header.Set("sec-gpc", "1")
	req.Header.Set("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36")

	res, err := client.HTTPClient.Do(req)
	HandleError(err)

	var reply GetCaptchaResponse

	err = json.NewDecoder(res.Body).Decode(&reply)
	HandleError(err)

	if client.Verbose {
		fmt.Println("[~] Completed: getcaptcha")
	}

	return &reply
}

func (client *HCaptcha) CreateAnswers(captcha *GetCaptchaResponse) map[string]string {
	question := captcha.RequesterQuestion.En
	answers := make(map[string]string, 0)
	object := strings.Replace(question, "Please click each image containing a ", "", 1)

	for _, task := range captcha.Tasklist {
		start := time.Now()

		if !strings.Contains(task.DatapointURI, object) {
			answers[task.TaskKey] = "false"

			if client.Verbose {
				fmt.Printf("[~] %v is not a %v (%v)\n", task.TaskKey, object, time.Since(start))
			}

			continue
		}

		if client.Verbose {
			fmt.Printf("[~] %v is a %v (%v)\n", task.TaskKey, object, time.Since(start))
		}

		answers[task.TaskKey] = "true"
	}

	return answers
}

func (client *HCaptcha) CheckCaptcha(captcha *GetCaptchaResponse, answers map[string]string, motionData string) *CheckCaptchaResponse {
	c_json, err := json.Marshal(captcha.C)
	HandleError(err)

	hash, err := HSWHashProof(captcha.C.Req)
	HandleError(err)

	body, err := json.Marshal(CheckCaptchaRequest{
		Answers:      answers,
		C:            string(c_json),
		JobMode:      "image_label_binary",
		MotionData:   motionData,
		N:            hash,
		Serverdomain: client.Host,
		Sitekey:      client.SiteKey,
		V:            Version,
	})

	HandleError(err)

	req, err := http.NewRequest("POST", fmt.Sprintf("%v/checkcaptcha/%s/%s", BaseURL, URLEncode(client.SiteKey), captcha.Key), bytes.NewReader(body))
	HandleError(err)

	req.Header.Set("accept", "*/*")
	req.Header.Set("accept-language", "en-GB,en-US;q=0.9,en;q=0.8")
	req.Header.Set("content-type", "application/json;charset=UTF-8")
	req.Header.Set("origin", "https://newassets.hcaptcha.com")
	req.Header.Set("referer", "https://newassets.hcaptcha.com/")
	req.Header.Set("sec-fetch-dest", "empty")
	req.Header.Set("sec-fetch-mode", "cors")
	req.Header.Set("sec-fetch-site", "same-site")
	req.Header.Set("sec-gpc", "1")
	req.Header.Set("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36")

	res, err := client.HTTPClient.Do(req)
	HandleError(err)

	var reply CheckCaptchaResponse

	err = json.NewDecoder(res.Body).Decode(&reply)
	HandleError(err)

	if client.Verbose {
		fmt.Println("[~] Completed: checkcaptcha")
	}

	return &reply
}

func (client *HCaptcha) Run() string {
	siteConfig := client.CheckSiteConfig()

	md := GenerateMotionData()
	motionData, err := json.Marshal(md)
	HandleError(err)

	captcha := client.GetCaptcha(siteConfig, string(motionData))
	if captcha.GeneratedPassUUID != "" {
		return captcha.GeneratedPassUUID
	}

	answers := client.CreateAnswers(captcha)

	FixCheckMD(md)
	motionData, err = json.Marshal(md)
	HandleError(err)

	reply := client.CheckCaptcha(captcha, answers, string(motionData))

	if client.Verbose {
		if reply.GeneratedPassUUID == "" {
			fmt.Println("[!] Failed to solve captcha")
		} else {
			fmt.Printf("[~] Passed captcha: %v\n", reply.GeneratedPassUUID)
		}
	}

	return reply.GeneratedPassUUID
}
